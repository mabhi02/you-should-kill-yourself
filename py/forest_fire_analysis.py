# -*- coding: utf-8 -*-
"""Forest Fire Analysis

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DIFVfSuRey_f4cj-TJccXy7T6BXpm8Hl
"""


import pandas as pd
from sklearn import *
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.linear_model import SGDClassifier
from sklearn.cluster import KMeans
import tensorflow as tf
import math

#Us
from google.colab import files
import io
uploaded1 = files.upload()

df = pd.read_csv('/content/FW_Veg_Rem_Combined.csv')
df.head()

#Global
from google.colab import files
import io
uploaded1 = files.upload()

df1 = pd.read_csv('/content/GlobalFireBurnedArea_2022.csv')
df1 = df1.drop(['ID', 'Initialdate', 'Finaldate', 'Area_Km2', 'Area_m2'], axis = 1)

df = df.dropna()

columns = ['fire_name', 'fire_size_class', 'latitude', 'longitude']
df = df[columns]

df = df.reset_index()
df = df.drop('index', axis = 1)

# Convert the 'Category' column to categorical
df['fire_size_class'] = df['fire_size_class'].astype('category')

# Convert categorical values to numerical codes
df['fire_size_class'] = df['fire_size_class'].cat.codes

dfNoName = df.drop('fire_name', axis = 1)

lat1 = 46 #User input here
lon1 = -111 #User input

def haversine_distance(lat1, lon1, lat2, lon2):
    # Radius of the Earth in miles
    R = 3959.0

    # Convert latitude and longitude from degrees to radians
    lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])

    # Calculate differences in coordinates
    dlat = lat2 - lat1
    dlon = lon2 - lon1

    # Haversine formula to calculate distance
    a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    distance = R * c

    return distance

def are_points_within_distance(lat1, lon1, lat2, lon2, max_distance):
    distance = haversine_distance(lat1, lon1, lat2, lon2)
    return distance <= max_distance

dfNew = pd.DataFrame()
max_distance = 100
for i in range(0, df.shape[0]-1):
  lats = df.loc[i, ['latitude']][0]
  longs = df.loc[i, ['longitude']][0]
  if are_points_within_distance(lat1, lon1, lats, longs, max_distance):
    row = df.iloc[i]
    dfNew = dfNew.append(row, ignore_index=True)

X = dfNew[['longitude', 'latitude']]
Y = dfNew[['fire_size_class']]

model = RandomForestClassifier()
model.fit(X,Y)

model.predict([[lon1, lat1]])

if (dfNew.shape[0] <= 3):
  dfNew = pd.DataFrame()
  print('Not enough data around here')

"""Global Df"""

# Assuming 'Area_ha' is a numerical column in your DataFrame
df1['Area_ha'] = df1['Area_ha'] / 100

# Define the bins and labels for each category
bins = [0, 0.25, 10, 100, 300, 1000, 3000, float('inf')]
labels = [0, 1, 2, 3, 4, 5, 6]

# Use pd.cut() to categorize 'Area_ha'
df1['Area_ha_category'] = pd.cut(df1['Area_ha'], bins=bins, labels=labels, right=False, include_lowest=True)

# If you want to replace the original 'Area_ha' column with the categories, you can do:
df1['Area_ha'] = df1['Area_ha_category']

# If you want to drop the intermediate 'Area_ha_category' column, you can do:
df1.drop('Area_ha_category', axis=1, inplace=True)

latitude = 48 #Do user input here
longitude = -234 #do user input here

from geopy.geocoders import Nominatim

def get_country_from_coordinates(latitude, longitude):
    # Initialize a geolocator
    geolocator = Nominatim(user_agent="geo_app")

    # Try to reverse geocode the coordinates
    try:
        location = geolocator.reverse((latitude, longitude), language="en")
        country = location.raw['address']['country']
        return country
    except Exception as e:
        print(f"Error: {e}")
        return None

country = get_country_from_coordinates(latitude, longitude)
dfNew1 = df1[df1['CountryName'] == country]

if country:
  print(f"The coordinates are in {country}.")
elif(country == 'United States'):
  print('Use the other dataset')
else:
  print("No fire")

if dfNew1.shape[0] == 0:
  print('No values in the dataset for this country')

# Assuming df is your DataFrame and 'class_column' is the name of your classification column
class_counts = dfNew1['Area_ha'].value_counts()

# The index of class_counts will contain the unique classes, and the values will contain the counts
most_frequent_class = class_counts.idxmax()
count_of_most_frequent_class = class_counts.max()

if (count_of_most_frequent_class == 0):
  most_frequent_class = 'Z'
  count_of_most_frequent_class = 0

print(f"The most frequent class is: {most_frequent_class}")
print(f"Count of the most frequent class: {count_of_most_frequent_class}")

def areaFromCategory(letter):
  if (letter == 0):
    return [0, 0.25]
  elif (letter == 1):
    return[0.25, 10]
  elif (letter == 2):
    return[10,100]
  elif (letter == 3):
    return[100, 300]
  elif (letter == 4):
    return[300, 1000]
  elif (letter == 5):
    return[1000, 3000]
  else:
    return "No Data"

prediction = model.predict([[lon1, lat1]])
areaFromCategory(prediction)

#Return values

#Us
prediction = model.predict([[lon1, lat1]])
rangeForPred = areaFromCategory(prediction)
graph = dfNew['fire_size_class'].value_counts().plot(kind='bar', color='skyblue', edgecolor='black')
table = dfNew

#World
prediction1  = dfNew1['Area_ha'].value_counts().idxmax()
rangeForPred1 = areaFromCategory(prediction1)
graph1 = dfNew1['Area_ha'].value_counts().plot(kind='bar', color='skyblue', edgecolor='black')
table1 = dfNew1

#Cool facts