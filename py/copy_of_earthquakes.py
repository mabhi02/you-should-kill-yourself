# -*- coding: utf-8 -*-
"""Copy of earthquakes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AFmbSY19g5e02EwT0iFaPZHg-pN3hR8C
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np

# These lines do some fancy plotting magic
import matplotlib
# %matplotlib inline
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
import warnings
warnings.simplefilter('ignore')
from datetime import datetime
import pandas as pd

#K NEAREST NEIGHBOR
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import accuracy_score
#k would be # of rows (data points) (#of rows-1)

from sklearn.datasets import load_digits
from sklearn.neighbors import RadiusNeighborsClassifier
import math
from sklearn.ensemble import RandomForestClassifier
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.linear_model import SGDClassifier
from sklearn.cluster import KMeans
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

df = pd.read_csv("/data/earthquake_1995-2023.csv")
df

def haversine_distance(lat1,lon1,lat2,lon2):
  R = 3959.0
  lat1,lon1,lat2,lon2 = map(math.radians,[lat1,lon1,lat2,lon2])

  dlat = lat2 - lat1
  dlon = lon2 - lon1
  a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2
  c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
  distance = R * c

  return distance
def are_points_within_distance(lat1, lon1, lat2, lon2, max_distance):
    distance = haversine_distance(lat1, lon1, lat2, lon2)
    return distance <= max_distance

dfNew = pd.DataFrame()
max_distance = 300
for i in range(0, df.shape[0]-1):
  lats = df.loc[i, ['latitude']][0]
  longs = df.loc[i, ['longitude']][0]
  if are_points_within_distance(lat1, lon1, lats, longs, max_distance):
    row = df.iloc[i]
    dfNew = dfNew.append(row, ignore_index=True)

dfNew.head()

"""NEAREST NEIGHBORS"""

df.head()

df.columns

columns = ['magnitude', 'date_time', 'latitude', 'longitude']

df = df[columns]

df.head()

lat1= 12
lon1 = -87

X = df[['longitude', 'latitude']]
Y = df[['magnitude']]
Xtrain, Xtest, Ytrain, Ytest = train_test_split(X, Y, test_size=0.2)

max_distance = 300 #more accurate, gathers more earthquakes in area radius
dfNew = pd.DataFrame(columns=df.columns)  # Initialize an empty DataFrame
for i in range(0, df.shape[0]):
  lats = df.loc[i, ['latitude']][0]
  longs = df.loc[i, ['longitude']][0]
  if are_points_within_distance(lat1, lon1, lats, longs, max_distance):
    row = df.iloc[i]
    dfNew = dfNew.append(row, ignore_index=True)

dfNew.shape[0]

dfNew

pred = 0
if dfNew.shape[0] < Xtrain.shape[0]:
  k = int(dfNew.shape[0]/2)
  knn_model = KNeighborsRegressor(n_neighbors=k)
  XN = dfNew[['longitude', 'latitude']]
  YN = dfNew[['magnitude']]
  XtrainN, XtestN, YtrainN, YtestN = train_test_split(XN, YN, test_size=0.2)
  knn_model.fit(XtrainN, YtrainN)
  pred = knn_model.predict([[lon1, lat1]])

else:
  model = RandomForestRegressor()
  model.fit(XN, YN)
  pred = model.predict([[lon1, lat1]])

pred

dfNew['date_time'] = pd.to_datetime(dfNew['date_time'])

dfNew['magnitude'].plot(kind='line')


plt.title('Magnitude Over the Year')
plt.xlabel('Date')
plt.ylabel('Value')
plt.grid(True)
plt.show()